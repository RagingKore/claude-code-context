using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace FluentSourceGen;

/// <summary>
/// Represents a projected query where types have been transformed to another type.
/// Enables chaining transformations before terminal operations.
/// </summary>
public sealed class ProjectedTypeQuery<T>
{
    readonly IncrementalGeneratorInitializationContext _roslynContext;
    readonly IncrementalValuesProvider<ProjectedItem<T>> _provider;
    readonly GeneratorContext _generatorContext;

    internal ProjectedTypeQuery(
        IncrementalGeneratorInitializationContext roslynContext,
        IncrementalValuesProvider<ProjectedItem<T>> provider,
        GeneratorContext generatorContext)
    {
        _roslynContext = roslynContext;
        _provider = provider;
        _generatorContext = generatorContext;
    }

    /// <summary>
    /// Filter projected items.
    /// </summary>
    public ProjectedTypeQuery<T> Where(Func<T, bool> predicate)
    {
        var filtered = _provider.Where(item => item.Value is not null && predicate(item.Value));
        return new ProjectedTypeQuery<T>(_roslynContext, filtered, _generatorContext);
    }

    /// <summary>
    /// Further project the items to another type.
    /// </summary>
    public ProjectedTypeQuery<TResult> Select<TResult>(Func<T, TResult> selector)
    {
        var projected = _provider.Select((item, _) =>
            item.Value is not null
                ? new ProjectedItem<TResult>(item.Symbol, selector(item.Value))
                : new ProjectedItem<TResult>(item.Symbol, default));

        return new ProjectedTypeQuery<TResult>(_roslynContext, projected, _generatorContext);
    }

    /// <summary>
    /// Collect all projected items and generate a single source file.
    /// Return (hintName, source) tuple, or null to skip generation.
    /// </summary>
    public void GenerateAll(Func<IReadOnlyList<(INamedTypeSymbol Symbol, T Data)>, (string HintName, string Source)?> generator)
    {
        var collected = _provider.Collect();
        var diagnostics = _generatorContext.Diagnostics;

        _generatorContext.AddSourceOutput(collected, (spc, items) =>
        {
            var pairs = items
                .Where(i => i.Value is not null && i.Symbol is not null)
                .Select(i => (i.Symbol!, i.Value!))
                .ToList();

            if (pairs.Count == 0) return;

            try
            {
                var result = generator(pairs);
                if (result is null) return;

                var normalizedSource = NormalizeSource(result.Value.Source);
                spc.AddSource(result.Value.HintName, SourceText.From(normalizedSource, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    diagnostics.UnhandledException,
                    Location.None,
                    "projected collection",
                    ex.Message));
            }
        });
    }

    /// <summary>
    /// Group projected items by a key.
    /// </summary>
    public ProjectedGroupedQuery<TKey, T> GroupBy<TKey>(Func<T, TKey> keySelector) where TKey : notnull
    {
        return new ProjectedGroupedQuery<TKey, T>(_roslynContext, _provider, keySelector, _generatorContext);
    }

    /// <summary>
    /// Get distinct projected items.
    /// </summary>
    public ProjectedTypeQuery<T> Distinct()
    {
        var collected = _provider.Collect();
        var distinctProvider = collected.SelectMany((items, _) =>
            items.Where(i => i.Value is not null).DistinctBy(i => i.Value));
        return new ProjectedTypeQuery<T>(_roslynContext, distinctProvider, _generatorContext);
    }

    /// <summary>
    /// Get distinct projected items using a custom comparer.
    /// </summary>
    public ProjectedTypeQuery<T> Distinct(IEqualityComparer<T> comparer)
    {
        var collected = _provider.Collect();
        var distinctProvider = collected.SelectMany((items, _) =>
            items.Where(i => i.Value is not null).DistinctBy(i => i.Value, comparer));
        return new ProjectedTypeQuery<T>(_roslynContext, distinctProvider, _generatorContext);
    }

    static string NormalizeSource(string source)
    {
        if (!source.TrimStart().StartsWith("//"))
        {
            return $"""
                // <auto-generated />
                // This file was auto-generated by FluentSourceGen.
                // Changes to this file may be lost when the file is regenerated.

                #nullable enable

                {source}
                """;
        }

        return source;
    }
}

/// <summary>
/// Represents a flattened projected query from SelectMany.
/// </summary>
public sealed class FlattenedTypeQuery<T>
{
    readonly IncrementalGeneratorInitializationContext _roslynContext;
    readonly IncrementalValuesProvider<FlattenedItem<T>> _provider;
    readonly GeneratorContext _generatorContext;

    internal FlattenedTypeQuery(
        IncrementalGeneratorInitializationContext roslynContext,
        IncrementalValuesProvider<FlattenedItem<T>> provider,
        GeneratorContext generatorContext)
    {
        _roslynContext = roslynContext;
        _provider = provider;
        _generatorContext = generatorContext;
    }

    /// <summary>
    /// Filter flattened items.
    /// </summary>
    public FlattenedTypeQuery<T> Where(Func<T, bool> predicate)
    {
        var filtered = _provider.Where(item => item.Value is not null && predicate(item.Value));
        return new FlattenedTypeQuery<T>(_roslynContext, filtered, _generatorContext);
    }

    /// <summary>
    /// Collect all flattened items and generate a single source file.
    /// Return (hintName, source) tuple, or null to skip generation.
    /// </summary>
    public void GenerateAll(Func<IReadOnlyList<(INamedTypeSymbol Symbol, T Data)>, (string HintName, string Source)?> generator)
    {
        var collected = _provider.Collect();
        var diagnostics = _generatorContext.Diagnostics;

        _generatorContext.AddSourceOutput(collected, (spc, items) =>
        {
            var pairs = items
                .Where(i => i.Value is not null && i.SourceSymbol is not null)
                .Select(i => (i.SourceSymbol!, i.Value!))
                .ToList();

            if (pairs.Count == 0) return;

            try
            {
                var result = generator(pairs);
                if (result is null) return;

                var normalizedSource = NormalizeSource(result.Value.Source);
                spc.AddSource(result.Value.HintName, SourceText.From(normalizedSource, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    diagnostics.UnhandledException,
                    Location.None,
                    "flattened collection",
                    ex.Message));
            }
        });
    }

    /// <summary>
    /// Get distinct items.
    /// </summary>
    public FlattenedTypeQuery<T> Distinct()
    {
        var collected = _provider.Collect();
        var distinctProvider = collected.SelectMany((items, _) =>
            items.Where(i => i.Value is not null).DistinctBy(i => i.Value));
        return new FlattenedTypeQuery<T>(_roslynContext, distinctProvider, _generatorContext);
    }

    static string NormalizeSource(string source)
    {
        if (!source.TrimStart().StartsWith("//"))
        {
            return $"""
                // <auto-generated />
                // This file was auto-generated by FluentSourceGen.
                // Changes to this file may be lost when the file is regenerated.

                #nullable enable

                {source}
                """;
        }

        return source;
    }
}

/// <summary>
/// Represents grouped projected items.
/// </summary>
public sealed class ProjectedGroupedQuery<TKey, T> where TKey : notnull
{
    readonly IncrementalGeneratorInitializationContext _roslynContext;
    readonly IncrementalValuesProvider<ProjectedItem<T>> _provider;
    readonly Func<T, TKey> _keySelector;
    readonly IEqualityComparer<TKey> _comparer;
    readonly GeneratorContext _generatorContext;

    internal ProjectedGroupedQuery(
        IncrementalGeneratorInitializationContext roslynContext,
        IncrementalValuesProvider<ProjectedItem<T>> provider,
        Func<T, TKey> keySelector,
        GeneratorContext generatorContext,
        IEqualityComparer<TKey>? comparer = null)
    {
        _roslynContext = roslynContext;
        _provider = provider;
        _keySelector = keySelector;
        _generatorContext = generatorContext;
        _comparer = comparer ?? EqualityComparer<TKey>.Default;
    }

    /// <summary>
    /// Generate source code for each group.
    /// Return (hintName, source) tuple, or null to skip generation for that group.
    /// </summary>
    public void Generate(Func<TKey, IReadOnlyList<T>, (string HintName, string Source)?> generator)
    {
        var keySelector = _keySelector;
        var comparer = _comparer;
        var diagnostics = _generatorContext.Diagnostics;

        var collected = _provider.Collect();

        _generatorContext.AddSourceOutput(collected, (spc, items) =>
        {
            var values = items
                .Where(i => i.Value is not null)
                .Select(i => i.Value!)
                .ToList();

            if (values.Count == 0) return;

            var groups = values.GroupBy(keySelector, comparer).ToList();

            foreach (var group in groups)
            {
                try
                {
                    var result = generator(group.Key, group.ToList());
                    if (result is null) continue;

                    var normalizedSource = NormalizeSource(result.Value.Source);
                    spc.AddSource(result.Value.HintName, SourceText.From(normalizedSource, Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        diagnostics.UnhandledException,
                        Location.None,
                        $"projected group '{group.Key}'",
                        ex.Message));
                }
            }
        });
    }

    static string NormalizeSource(string source)
    {
        if (!source.TrimStart().StartsWith("//"))
        {
            return $"""
                // <auto-generated />
                // This file was auto-generated by FluentSourceGen.
                // Changes to this file may be lost when the file is regenerated.

                #nullable enable

                {source}
                """;
        }

        return source;
    }
}

/// <summary>
/// Represents a projected item with its source symbol.
/// </summary>
internal readonly record struct ProjectedItem<T>(INamedTypeSymbol? Symbol, T? Value);

/// <summary>
/// Represents a flattened item from SelectMany with its source symbol.
/// </summary>
internal readonly record struct FlattenedItem<T>(INamedTypeSymbol? SourceSymbol, T? Value);
