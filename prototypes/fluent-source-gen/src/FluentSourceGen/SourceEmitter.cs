using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace FluentSourceGen;

/// <summary>
/// Provides methods for emitting generated source code and diagnostics.
/// </summary>
public sealed class SourceEmitter
{
    readonly SourceProductionContext _context;
    readonly INamedTypeSymbol _typeSymbol;

    internal SourceEmitter(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        _context = context;
        _typeSymbol = typeSymbol;
    }

    /// <summary>
    /// Gets the type symbol being processed.
    /// </summary>
    public INamedTypeSymbol Type => _typeSymbol;

    /// <summary>
    /// Emits source code with a simple hint name.
    /// </summary>
    public void Source(string hintName, string source)
    {
        var normalizedSource = NormalizeSource(source);
        _context.AddSource(hintName, SourceText.From(normalizedSource, Encoding.UTF8));
    }

    /// <summary>
    /// Emits source code with configurable file naming options.
    /// </summary>
    public void Source(FileNamingOptions options, string source, params ITypeSymbol[] typeArgsForHash)
    {
        var hintName = SourceGeneratorFileNaming.GetHintName(_typeSymbol, options, typeArgsForHash);
        Source(hintName, source);
    }

    static string NormalizeSource(string source)
    {
        if (!source.TrimStart().StartsWith("//"))
        {
            return $"""
                // <auto-generated />
                // This file was auto-generated by FluentSourceGen.
                // Changes to this file may be lost when the file is regenerated.

                #nullable enable

                {source}
                """;
        }

        return source;
    }

    /// <summary>
    /// Reports an informational diagnostic.
    /// </summary>
    public void ReportInfo(string id, string title, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id, title, message, "FluentSourceGen",
            DiagnosticSeverity.Info, isEnabledByDefault: true);
        _context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
    }

    /// <summary>
    /// Reports a warning diagnostic.
    /// </summary>
    public void ReportWarning(string id, string title, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id, title, message, "FluentSourceGen",
            DiagnosticSeverity.Warning, isEnabledByDefault: true);
        _context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
    }

    /// <summary>
    /// Reports an error diagnostic.
    /// </summary>
    public void ReportError(string id, string title, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id, title, message, "FluentSourceGen",
            DiagnosticSeverity.Error, isEnabledByDefault: true);
        _context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
    }

    /// <summary>
    /// Reports a diagnostic with the type's location.
    /// </summary>
    public void ReportDiagnostic(DiagnosticSeverity severity, string id, string title, string message)
    {
        var location = _typeSymbol.Locations.FirstOrDefault() ?? Location.None;
        var descriptor = new DiagnosticDescriptor(
            id, title, message, "FluentSourceGen",
            severity, isEnabledByDefault: true);
        _context.ReportDiagnostic(Diagnostic.Create(descriptor, location));
    }
}
